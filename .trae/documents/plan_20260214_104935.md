Para evitar que valores negociados sejam tratados incorretamente como divergência, refinamos a lógica de verificação.

O sistema fará a distinção entre **preço de tabela** (calculado) e **preço negociado** (manual).

### Lógica Refinada

A verificação comparará o **`valorCalculado`** (preço original da tabela no momento da criação) com o **Novo Preço de Tabela**.

#### Cenário 1: Agendamento SEM valor negociado
- **Condição:** `valorNegociado` é nulo.
- **Verificação:** Se `valorCalculado` (antigo) ≠ `NovoValorTabela`.
- **Ação:** Exibe alerta **amarelo** informando que a tabela mudou e oferece botão para **"Atualizar Preço"** para o novo valor da tabela.

#### Cenário 2: Agendamento COM valor negociado
- **Condição:** `valorNegociado` está preenchido (ex: desconto ou acordo).
- **Verificação:** O sistema detecta que há um valor manual.
- **Ação:**
    - Se a tabela base mudou (ex: era R$ 100, agora é R$ 120), exibe um alerta **azul (informativo)**: *"A tabela base sofreu reajuste (de R$ 100 para R$ 120), mas o valor negociado de R$ 90 está mantido."*
    - **Não** sugere atualização automática para o valor cheio, preservando a negociação.
    - O gestor pode decidir manualmente se quer renegociar o valor com base na nova tabela.

### Implementação Técnica

1.  **Backend (`/api/agendamento/[id]/verificar-preco`)**:
    - Retornará: `precoTabelaAntigo` (do banco), `precoTabelaNovo` (calculado agora), e `precoNegociado`.

2.  **Frontend (`EditarAgendamentoModal`)**:
    - Implementará a lógica condicional acima para exibir o tipo de alerta correto (Aviso vs Informação) e a ação apropriada.

Isso garante que reajustes de tabela sejam notificados, mas acordos específicos (negociados) sejam respeitados e não subscritos acidentalmente.
